<!DOCTYPE html>
<html lang="da">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Adminpanel - Fjernskrivebord</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üñ•Ô∏è</text></svg>">
  <link rel="stylesheet" href="css/styles.css?v=4">
  <link rel="stylesheet" href="css/loading-states.css?v=4">
  <link rel="stylesheet" href="css/mobile.css?v=4">
  <link rel="stylesheet" href="css/accessibility.css?v=4">
  <link rel="stylesheet" href="css/empty-states.css?v=4">
  <link rel="stylesheet" href="css/modern.css?v=4">
  <script>if(localStorage.getItem('theme')==='light')document.documentElement.setAttribute('data-theme','light');</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body>
  <!-- Animated Background -->
  <div class="animated-bg">
    <div class="gradient-orb orb-1"></div>
    <div class="gradient-orb orb-2"></div>
    <div class="gradient-orb orb-3"></div>
  </div>

  <div class="admin-container">
    <!-- Header -->
    <div class="admin-header">
      <h1>üîê Adminpanel</h1>
      <div class="header-actions">
        <button onclick="window.location.href='dashboard.html'" class="btn btn-secondary btn-sm">‚Üê Kontrolpanel</button>
        <button onclick="logout()" class="btn btn-secondary btn-sm">Log ud</button>
      </div>
    </div>

    <!-- Super Admin Badge -->
    <div id="superAdminBadge" class="super-admin-badge" style="display: none;">
      ‚≠ê Super Admin
    </div>

    <!-- Tabs -->
    <div class="admin-tabs">
      <button onclick="showTab('users')" id="tabUsers" class="admin-tab active">üë• Brugergodkendelser</button>
      <button onclick="showTab('devices')" id="tabDevices" class="admin-tab">üì± Enhedsstyring</button>
      <button onclick="showTab('remote')" id="tabRemote" class="admin-tab">üñ•Ô∏è Remote Control</button>
      <button onclick="showTab('invites')" id="tabInvites" class="admin-tab">‚úâÔ∏è Invitationer</button>
      <button onclick="showTab('transfers')" id="tabTransfers" class="admin-tab" style="display: none;">üîÑ Enhedsoverf√∏rsler</button>
    </div>

    <!-- Downloads Section -->
    <div style="background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 1.5rem; margin-bottom: 2rem; border: 1px solid rgba(255, 255, 255, 0.1);">
      <h3 style="margin: 0 0 1rem 0; font-size: 1.125rem;">üì• Downloads</h3>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem;">
        <a href="https://downloads.hawkeye123.dk/remote-agent.exe" 
           class="btn btn-primary" 
           style="text-decoration: none; text-align: center;">
          üñ•Ô∏è Windows Agent
        </a>
        <a href="agent.html" 
           class="btn btn-primary" 
           style="text-decoration: none; text-align: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
          üåê Web Agent
        </a>
        <a href="https://downloads.hawkeye123.dk/controller.exe" 
           class="btn btn-secondary" 
           style="text-decoration: none; text-align: center;">
          üéÆ Controller
        </a>
      </div>
      <p style="margin-top: 0.75rem; font-size: 0.875rem; color: #aaa; text-align: center;">
        Windows Agent (anbefalet) ‚Ä¢ Web Agent (browser) ‚Ä¢ Controller (kontrol enheder)
      </p>
    </div>

    <!-- Users Tab -->
    <div id="usersTab" class="tab-content">
      <!-- Stats -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="totalUsers">0</div>
          <div class="stat-label">Brugere i alt</div>
        </div>
        <div class="stat-card warning">
          <div class="stat-number" id="pendingUsers">0</div>
          <div class="stat-label">Afventer godkendelse</div>
        </div>
        <div class="stat-card success">
          <div class="stat-number" id="approvedUsers">0</div>
          <div class="stat-label">Godkendte brugere</div>
        </div>
      </div>

      <!-- Filters -->
      <div class="filter-tabs">
        <button onclick="filterUsers('all')" class="filter-tab active" id="filterAll">Alle brugere</button>
        <button onclick="filterUsers('pending')" class="filter-tab" id="filterPending">Afventende</button>
        <button onclick="filterUsers('approved')" class="filter-tab" id="filterApproved">Godkendte</button>
      </div>

      <!-- Users List -->
      <div id="usersList"></div>
    </div>

    <!-- Devices Tab -->
    <div id="devicesTab" class="tab-content" style="display: none;">
      <!-- Device Stats -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="totalDevices">0</div>
          <div class="stat-label">Enheder i alt</div>
        </div>
        <div class="stat-card warning">
          <div class="stat-number" id="unassignedDevices">0</div>
          <div class="stat-label">Ikke tildelt</div>
        </div>
        <div class="stat-card success">
          <div class="stat-number" id="onlineDevices">0</div>
          <div class="stat-label">Online</div>
        </div>
      </div>

      <!-- Device Filters -->
      <div class="filter-tabs">
        <button onclick="filterDevices('all')" class="filter-tab active" id="filterAllDevices">Alle enheder</button>
        <button onclick="filterDevices('unassigned')" class="filter-tab" id="filterUnassigned">Ikke tildelt</button>
        <button onclick="filterDevices('assigned')" class="filter-tab" id="filterAssigned">Tildelt</button>
      </div>

      <!-- Devices List -->
      <div id="devicesList"></div>
    </div>

    <!-- Invitations Tab -->
    <div id="invitesTab" class="tab-content" style="display: none;">
      <div class="invite-section">
        <h3>üì® Send invitation</h3>
        <div class="invite-form">
          <div class="form-group">
            <label for="inviteEmail">E-mailadresse</label>
            <input type="email" id="inviteEmail" class="input" placeholder="user@example.com">
          </div>
          <div class="form-group">
            <label for="inviteRole">Rolle</label>
            <select id="inviteRole" class="input">
              <option value="user">Bruger</option>
              <option value="admin" id="adminRoleOption" style="display: none;">Administrator</option>
            </select>
          </div>
          <button onclick="sendInvitation()" class="btn btn-primary">Send invitation</button>
        </div>
      </div>
      
      <h3 style="margin-top: 2rem;">üìã Sendte invitationer</h3>
      <div id="invitationsList"></div>
    </div>

    <!-- Remote Control Tab -->
    <div id="remoteTab" class="tab-content" style="display: none;">
      <h3>üñ•Ô∏è Remote Control - Administrer enheder direkte</h3>
      
      <!-- Device Selection -->
      <div class="form-group" style="max-width: 600px; margin-bottom: 2rem;">
        <label for="remoteDeviceSelect">V√¶lg enhed at kontrollere</label>
        <select id="remoteDeviceSelect" class="input" onchange="selectRemoteDevice()">
          <option value="">V√¶lg en online enhed...</option>
        </select>
      </div>

      <!-- Remote Preview Container -->
      <div id="remotePreviewContainer" style="display: none;">
        <div class="remote-preview-section">
          <div class="section-header">
            <h3 id="remoteDeviceName">Enhed</h3>
            <div class="preview-controls">
              <button id="remoteDisconnectBtn" class="btn btn-danger btn-sm" onclick="disconnectRemote()">Afbryd</button>
            </div>
          </div>
          
          <!-- Video Preview -->
          <div class="preview-container" style="position: relative; background: #000; border-radius: 12px; overflow: hidden; aspect-ratio: 16/9;">
            <canvas id="remoteCanvas" style="width: 100%; height: 100%; object-fit: contain;"></canvas>
            <div id="remoteStatus" style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 6px; font-size: 14px;">
              üî¥ Ikke forbundet
            </div>
            <div id="remoteStats" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; display: none;">
              FPS: 0 | RTT: 0ms
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Device Transfers Tab (Super Admin Only) -->
    <div id="transfersTab" class="tab-content" style="display: none;">
      <h3>üîÑ Overf√∏r enhed til en anden administrator</h3>
      <div class="transfer-form">
        <div class="form-group">
          <label for="transferDevice">V√¶lg enhed</label>
          <select id="transferDevice" class="input">
            <option value="">V√¶lg en enhed...</option>
          </select>
        </div>
        <div class="form-group">
          <label for="transferToUser">Overf√∏r til</label>
          <select id="transferToUser" class="input">
            <option value="">V√¶lg en bruger...</option>
          </select>
        </div>
        <div class="form-group">
          <label for="transferReason">√Örsag (valgfri)</label>
          <input type="text" id="transferReason" class="input" placeholder="Hvorfor overf√∏rer du denne enhed?">
        </div>
        <button onclick="transferDevice()" class="btn btn-primary">Overf√∏r enhed</button>
      </div>
      
      <h3 style="margin-top: 2rem;">üìú Overf√∏rselshistorik</h3>
      <div id="transferHistory"></div>
    </div>
  </div>

  <!-- Assignment Modal -->
  <div id="assignModal" class="modal" style="display: none;">
    <div class="modal-content">
      <h3>Tildel enhed</h3>
      <div class="modal-body">
        <div id="modalDeviceName" style="margin-bottom: 1rem; font-weight: 600;"></div>
        <div class="form-group">
          <label for="userSelect">Tildel til bruger</label>
          <select id="userSelect" class="form-group input" style="width: 100%; padding: 0.75rem; background: var(--background); border: 1px solid var(--border); border-radius: 8px; color: var(--text);">
            <option value="">Select a user...</option>
          </select>
        </div>
        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
          <input type="checkbox" id="approveDevice" checked>
          <span>Godkend enhed til brug</span>
        </label>
      </div>
      <div class="modal-actions">
        <button onclick="closeAssignModal()" class="btn btn-secondary">Annuller</button>
        <button onclick="confirmAssignment()" class="btn btn-primary">Tildel enhed</button>
      </div>
    </div>
  </div>

  <!-- Error Boundary -->
  <script src="js/error-boundary.js?v=4"></script>
  
  <!-- UI Helpers -->
  <script src="js/ui-helpers.js?v=4"></script>
  
  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="js/config.js?v=4"></script>
  <script>

    let currentFilter = 'all';
    let allUsers = [];
    let currentDeviceFilter = 'all';
    let allDevices = [];
    let assignedDevices = [];
    let currentAssignDevice = null;
    let isSuperAdmin = false;
    let currentUserId = null;

    // Initialize on page load
    async function init() {
      // Check if user is logged in
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        window.location.href = 'login.html';
        return;
      }
      
      currentUserId = session.user.id;
      
      // Check if user is admin
      const { data: approval } = await supabase
        .from('user_approvals')
        .select('role')
        .eq('user_id', session.user.id)
        .single();
      
      if (!approval || !['admin', 'super_admin'].includes(approval.role)) {
        showToast('‚õî Adgang n√¶gtet. Admin-rettigheder kr√¶ves.', 'error');
        setTimeout(() => window.location.href = 'index.html', 1500);
        return;
      }
      
      // Check if super admin
      isSuperAdmin = approval.role === 'super_admin';
      if (isSuperAdmin) {
        document.getElementById('superAdminBadge').style.display = 'block';
        document.getElementById('tabTransfers').style.display = 'inline-block';
        document.getElementById('adminRoleOption').style.display = 'block';
      }
      
      // Load initial data
      await loadUsers();
      await loadInvitations();
      if (isSuperAdmin) {
        await loadTransferData();
      }
      
      // Auto-refresh every 30 seconds
      setInterval(loadUsers, 30000);
    }
    
    // Show tab
    function showTab(tab) {
      // Hide all tabs
      document.querySelectorAll('.tab-content').forEach(t => t.style.display = 'none');
      document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
      
      // Show selected tab
      document.getElementById(tab + 'Tab').style.display = 'block';
      document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
      
      // Load data for tab
      if (tab === 'devices') loadDevices();
      if (tab === 'invites') loadInvitations();
      if (tab === 'transfers' && isSuperAdmin) loadTransferData();
    }
    
    // Send invitation
    async function sendInvitation() {
      const email = document.getElementById('inviteEmail').value.trim();
      const role = document.getElementById('inviteRole').value;
      
      if (!email) {
        showToast('Indtast venligst en e-mailadresse', 'warning');
        return;
      }
      
      try {
        const { data, error } = await supabase.rpc('send_invitation', {
          p_email: email,
          p_role: role
        });
        
        if (error) throw error;
        
        const inviteUrl = window.location.origin + '/Remote/index.html?invite=' + data;
        
        showToast('Invitation sendt! Link kopieret til udklipsholder.', 'success', 5000);
        navigator.clipboard.writeText(inviteUrl).catch(() => {});
        document.getElementById('inviteEmail').value = '';
        loadInvitations();
        
      } catch (error) {
        console.error('Error sending invitation:', error);
        showToast('Kunne ikke sende invitation: ' + error.message, 'error');
      }
    }
    
    // Load invitations
    async function loadInvitations() {
      try {
        const { data: invitations, error } = await supabase
          .from('user_invitations')
          .select('*')
          .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        const container = document.getElementById('invitationsList');
        if (!invitations || invitations.length === 0) {
          container.innerHTML = '<p style="color: var(--text-secondary);">No invitations sent yet.</p>';
          return;
        }
        
        container.innerHTML = invitations.map(inv => `
          <div class="user-card">
            <div class="user-info">
              <div class="user-email">${inv.email}</div>
              <div class="user-meta">
                Role: ${inv.role} | 
                Sent: ${new Date(inv.created_at).toLocaleDateString()} |
                Status: ${inv.accepted_at ? '‚úÖ Accepted' : (new Date(inv.expires_at) < new Date() ? '‚ùå Expired' : '‚è≥ Pending')}
              </div>
            </div>
          </div>
        `).join('');
        
      } catch (error) {
        console.error('Error loading invitations:', error);
      }
    }
    
    // Load transfer data (super admin only)
    async function loadTransferData() {
      try {
        // Load all devices for transfer dropdown
        const { data: devices } = await supabase
          .from('remote_devices')
          .select('device_id, device_name, owner_id');
        
        const deviceSelect = document.getElementById('transferDevice');
        deviceSelect.innerHTML = '<option value="">Select a device...</option>' +
          (devices || []).map(d => `<option value="${d.device_id}">${d.device_name || d.device_id}</option>`).join('');
        
        // Load all users for transfer dropdown
        const { data: users } = await supabase
          .from('user_approvals')
          .select('user_id, role');
        
        // Get user emails
        const userSelect = document.getElementById('transferToUser');
        userSelect.innerHTML = '<option value="">Select a user...</option>' +
          (users || []).map(u => `<option value="${u.user_id}">${u.user_id} (${u.role})</option>`).join('');
        
        // Load transfer history
        const { data: transfers } = await supabase
          .from('device_transfers')
          .select('*')
          .order('transferred_at', { ascending: false })
          .limit(20);
        
        const historyContainer = document.getElementById('transferHistory');
        if (!transfers || transfers.length === 0) {
          historyContainer.innerHTML = '<p style="color: var(--text-secondary);">No transfers yet.</p>';
          return;
        }
        
        historyContainer.innerHTML = transfers.map(t => `
          <div class="user-card">
            <div class="user-info">
              <div class="user-email">Device: ${t.device_id}</div>
              <div class="user-meta">
                From: ${t.from_user_id || 'Unassigned'} ‚Üí To: ${t.to_user_id} |
                ${new Date(t.transferred_at).toLocaleString()}
                ${t.reason ? ' | Reason: ' + t.reason : ''}
              </div>
            </div>
          </div>
        `).join('');
        
      } catch (error) {
        console.error('Error loading transfer data:', error);
      }
    }
    
    // Transfer device
    async function transferDevice() {
      const deviceId = document.getElementById('transferDevice').value;
      const toUserId = document.getElementById('transferToUser').value;
      const reason = document.getElementById('transferReason').value;
      
      if (!deviceId || !toUserId) {
        showToast('V√¶lg venligst b√•de en enhed og en bruger', 'warning');
        return;
      }
      
      try {
        const { data, error } = await supabase.rpc('transfer_device', {
          p_device_id: deviceId,
          p_to_user_id: toUserId,
          p_reason: reason || null
        });
        
        if (error) throw error;
        
        showToast('Enhed overf√∏rt!', 'success');
        document.getElementById('transferDevice').value = '';
        document.getElementById('transferToUser').value = '';
        document.getElementById('transferReason').value = '';
        loadTransferData();
        
      } catch (error) {
        console.error('Error transferring device:', error);
        showToast('Kunne ikke overf√∏re enhed: ' + error.message, 'error');
      }
    }

    async function loadUsers() {
      try {
        // Get all user approvals
        const { data: approvals, error } = await supabase
          .from('user_approvals')
          .select('*')
          .order('requested_at', { ascending: false });

        if (error) throw error;

        allUsers = approvals || [];
        updateStats();
        displayUsers();
      } catch (error) {
        console.error('Error loading users:', error);
        showToast('Kunne ikke indl√¶se brugere: ' + error.message, 'error');
      }
    }

    function updateStats() {
      const total = allUsers.length;
      const pending = allUsers.filter(u => !u.approved).length;
      const approved = allUsers.filter(u => u.approved).length;

      document.getElementById('totalUsers').textContent = total;
      document.getElementById('pendingUsers').textContent = pending;
      document.getElementById('approvedUsers').textContent = approved;
    }

    function displayUsers() {
      const usersList = document.getElementById('usersList');
      let filteredUsers = allUsers;

      if (currentFilter === 'pending') {
        filteredUsers = allUsers.filter(u => !u.approved);
      } else if (currentFilter === 'approved') {
        filteredUsers = allUsers.filter(u => u.approved);
      }

      if (filteredUsers.length === 0) {
        usersList.innerHTML = '<p style="text-align: center; color: #666;">No users found.</p>';
        return;
      }

      usersList.innerHTML = filteredUsers.map(user => `
        <div class="pending-user ${user.approved ? 'approved' : ''}">
          <div class="user-header">
            <div class="user-email">
              ${user.email}
              ${user.role === 'admin' ? '<span class="admin-badge">üëë Admin</span>' : ''}
            </div>
            <span class="user-status ${user.approved ? 'status-approved' : 'status-pending'}">
              ${user.approved ? '‚úÖ Approved' : '‚è∏Ô∏è Pending'}
            </span>
          </div>
          <div class="user-details">
            <div>Requested: ${new Date(user.requested_at).toLocaleString()}</div>
            ${user.approved ? `<div>Approved: ${new Date(user.approved_at).toLocaleString()}</div>` : ''}
            ${user.notes ? `<div>Notes: ${user.notes}</div>` : ''}
            <div>Role: ${user.role || 'user'}</div>
          </div>
          <div class="user-actions">
            <button 
              class="approve-btn" 
              onclick="approveUser('${user.user_id}', '${user.email}')"
              ${user.approved ? 'disabled' : ''}
            >
              ${user.approved ? 'Already Approved' : 'Approve User'}
            </button>
            ${user.approved && user.role !== 'admin' ? `
              <button 
                class="admin-btn" 
                onclick="makeAdmin('${user.user_id}', '${user.email}')"
              >
                üëë Make Admin
              </button>
            ` : ''}
            ${user.role === 'admin' ? `
              <button 
                class="revoke-admin-btn" 
                onclick="revokeAdmin('${user.user_id}', '${user.email}')"
              >
                ‚ùå Remove Admin
              </button>
            ` : ''}
          </div>
        </div>
      `).join('');
    }

    window.filterUsers = function(filter) {
      currentFilter = filter;
      
      // Update button states
      document.getElementById('filterAll').classList.toggle('active', filter === 'all');
      document.getElementById('filterPending').classList.toggle('active', filter === 'pending');
      document.getElementById('filterApproved').classList.toggle('active', filter === 'approved');
      
      displayUsers();
    };

    window.approveUser = async function(userId, email) {
      if (!await showConfirm(`Godkend bruger: ${email}?\n\nEn velkomst-e-mail vil blive sendt.`, { title: 'Godkend bruger', confirmText: 'Godkend', type: 'info', icon: '‚úÖ' })) return;

      try {
        // Call the approve_user function
        const { data, error } = await supabase.rpc('approve_user', {
          target_user_id: userId,
          approval_notes: 'Approved by admin'
        });

        if (error) throw error;

        // Send welcome email via Edge Function
        let emailSent = false;
        try {
          const { data: { session } } = await supabase.auth.getSession();
          const response = await supabase.functions.invoke('send-welcome-email', {
            body: { email },
            headers: {
              Authorization: `Bearer ${session.access_token}`
            }
          });
          
          if (response.data?.success) {
            console.log('‚úÖ Welcome email sent:', response.data);
            emailSent = true;
          } else {
            console.warn('‚ö†Ô∏è Email failed:', response.data?.message || response.error);
          }
        } catch (emailError) {
          console.warn('‚ö†Ô∏è Could not send welcome email:', emailError);
        }

        showToast(`Bruger godkendt: ${email}${emailSent ? ' ‚Äî Velkomst-e-mail sendt!' : ''}`, 'success', 5000);
        await loadUsers();
      } catch (error) {
        console.error('Error approving user:', error);
        showToast('Kunne ikke godkende bruger: ' + error.message, 'error');
      }
    };

    window.logout = async function() {
      await supabase.auth.signOut();
      window.location.href = 'login.html?status=logout';
    };

    window.makeAdmin = async function(userId, email) {
      if (!await showConfirm(`G√∏r ${email} til admin?\n\nBrugeren vil kunne:\n‚Ä¢ Godkende nye brugere\n‚Ä¢ Administrere enheder\n‚Ä¢ G√∏re andre til admin`, { title: 'Giv admin-rettigheder', confirmText: 'G√∏r til admin', type: 'warning', icon: 'üëë' })) return;

      try {
        const { data, error } = await supabase
          .from('user_approvals')
          .update({ role: 'admin' })
          .eq('user_id', userId);

        if (error) throw error;

        showToast(`${email} er nu admin!`, 'success');
        await loadUsers();
      } catch (error) {
        console.error('Error making admin:', error);
        showToast('Kunne ikke give admin-rettigheder: ' + error.message, 'error');
      }
    };

    window.revokeAdmin = async function(userId, email) {
      // Get current user to prevent self-demotion
      const { data: { session } } = await supabase.auth.getSession();
      if (session.user.id === userId) {
        showToast('Du kan ikke fjerne dine egne admin-rettigheder!', 'warning');
        return;
      }

      if (!await showConfirm(`Fjern admin-rettigheder fra ${email}?\n\nBrugeren vil ikke l√¶ngere have adgang til admin-panelet.`, { title: 'Fjern admin', confirmText: 'Fjern', type: 'danger', icon: '‚ùå' })) return;

      try {
        const { data, error } = await supabase
          .from('user_approvals')
          .update({ role: 'user' })
          .eq('user_id', userId);

        if (error) throw error;

        showToast(`Admin-rettigheder fjernet fra ${email}`, 'success');
        await loadUsers();
      } catch (error) {
        console.error('Error revoking admin:', error);
        showToast('Kunne ikke fjerne admin-rettigheder: ' + error.message, 'error');
      }
    };

    // ===== DEVICE MANAGEMENT =====

    async function loadDevices() {
      try {
        // Get all devices
        const { data: devices, error: devicesError } = await supabase
          .from('remote_devices')
          .select('*')
          .order('created_at', { ascending: false });

        if (devicesError) throw devicesError;

        // Get all assignments (without join to user_approvals)
        const { data: assignments, error: assignError } = await supabase
          .from('device_assignments')
          .select('*')
          .is('revoked_at', null);

        if (assignError) throw assignError;

        // Get user emails for assignments
        if (assignments && assignments.length > 0) {
          const userIds = [...new Set(assignments.map(a => a.user_id))];
          const { data: users } = await supabase
            .from('user_approvals')
            .select('user_id, email')
            .in('user_id', userIds);
          
          // Map emails to assignments
          const userMap = {};
          if (users) {
            users.forEach(u => userMap[u.user_id] = u.email);
          }
          assignments.forEach(a => {
            a.user_email = userMap[a.user_id] || 'Unknown';
          });
        }

        allDevices = devices || [];
        assignedDevices = assignments || [];
        
        updateDeviceStats();
        displayDevices();
      } catch (error) {
        console.error('Error loading devices:', error);
        showToast('Kunne ikke indl√¶se enheder: ' + error.message, 'error');
      }
    }

    function updateDeviceStats() {
      const total = allDevices.length;
      const assigned = assignedDevices.length;
      const unassigned = total - assigned;
      const online = allDevices.filter(d => d.is_online).length;

      document.getElementById('totalDevices').textContent = total;
      document.getElementById('unassignedDevices').textContent = unassigned;
      document.getElementById('onlineDevices').textContent = online;
    }

    function displayDevices() {
      const devicesList = document.getElementById('devicesList');
      let filteredDevices = allDevices;

      // Filter devices
      if (currentDeviceFilter === 'unassigned') {
        const assignedIds = assignedDevices.map(a => a.device_id);
        filteredDevices = allDevices.filter(d => !assignedIds.includes(d.device_id));
      } else if (currentDeviceFilter === 'assigned') {
        const assignedIds = assignedDevices.map(a => a.device_id);
        filteredDevices = allDevices.filter(d => assignedIds.includes(d.device_id));
      }

      if (filteredDevices.length === 0) {
        devicesList.innerHTML = '<p style="text-align: center; color: #666;">No devices found.</p>';
        return;
      }

      devicesList.innerHTML = filteredDevices.map(device => {
        const assignment = assignedDevices.find(a => a.device_id === device.device_id);
        const isAssigned = !!assignment;
        const statusClass = device.is_online ? 'status-online' : 'status-offline';
        const statusText = device.is_online ? 'üü¢ Online' : 'üî¥ Offline';

        return `
          <div class="device-card ${isAssigned ? 'assigned' : 'unassigned'}">
            <div class="device-header">
              <div class="device-name">${device.device_name || device.device_id}</div>
              <span class="device-status-badge ${statusClass}">${statusText}</span>
            </div>
            <div class="device-details">
              <div>Device ID: ${device.device_id}</div>
              <div>Platform: ${device.platform || 'Unknown'}</div>
              <div>Created: ${new Date(device.created_at).toLocaleString()}</div>
              ${device.last_heartbeat ? `<div>Last Seen: ${new Date(device.last_heartbeat).toLocaleString()}</div>` : ''}
              ${isAssigned ? `<div>‚úÖ Assigned to: ${assignment.user_email}</div>` : '<div>‚ö†Ô∏è Not assigned to any user</div>'}
              ${device.approved_at ? '<div>‚úÖ Approved for use</div>' : '<div>‚è∏Ô∏è Pending approval</div>'}
            </div>
            <div class="device-actions">
              ${!isAssigned ? `
                <button class="assign-btn" onclick="showAssignModal('${device.device_id}', '${device.device_name || device.device_id}')">
                  Assign to User
                </button>
              ` : `
                <button class="revoke-btn" onclick="revokeAssignment('${device.device_id}', '${assignment.user_id}')">
                  Revoke Assignment
                </button>
              `}
            </div>
          </div>
        `;
      }).join('');
    }

    window.filterDevices = function(filter) {
      currentDeviceFilter = filter;
      
      // Update button states
      document.getElementById('filterAllDevices').classList.toggle('active', filter === 'all');
      document.getElementById('filterUnassigned').classList.toggle('active', filter === 'unassigned');
      document.getElementById('filterAssigned').classList.toggle('active', filter === 'assigned');
      
      displayDevices();
    };

    window.showAssignModal = function(deviceId, deviceName) {
      currentAssignDevice = deviceId;
      document.getElementById('modalDeviceName').textContent = `Device: ${deviceName}`;
      
      // Populate user dropdown with approved users
      const userSelect = document.getElementById('userSelect');
      const approvedUsers = allUsers.filter(u => u.approved);
      
      userSelect.innerHTML = '<option value="">Select a user...</option>' +
        approvedUsers.map(u => `<option value="${u.user_id}">${u.email}</option>`).join('');
      
      document.getElementById('assignModal').style.display = 'block';
    };

    window.closeAssignModal = function() {
      document.getElementById('assignModal').style.display = 'none';
      currentAssignDevice = null;
    };

    window.confirmAssignment = async function() {
      const userId = document.getElementById('userSelect').value;
      const approveDevice = document.getElementById('approveDevice').checked;

      if (!userId) {
        showToast('V√¶lg venligst en bruger', 'warning');
        return;
      }

      try {
        // Call assign_device function
        const { data, error } = await supabase.rpc('assign_device', {
          p_device_id: currentAssignDevice,
          p_user_id: userId,
          p_approve_device: approveDevice
        });

        if (error) throw error;

        showToast('Enhed tildelt!', 'success');
        closeAssignModal();
        await loadDevices();
      } catch (error) {
        console.error('Error assigning device:', error);
        showToast('Kunne ikke tildele enhed: ' + error.message, 'error');
      }
    };

    window.revokeAssignment = async function(deviceId, userId) {
      if (!await showConfirm('Fjern denne enhedstildeling?', { title: 'Fjern tildeling', confirmText: 'Fjern', type: 'danger' })) return;

      try {
        const { data, error } = await supabase.rpc('revoke_device_assignment', {
          p_device_id: deviceId,
          p_user_id: userId
        });

        if (error) throw error;

        showToast('Tildeling fjernet', 'success');
        await loadDevices();
      } catch (error) {
        console.error('Error revoking assignment:', error);
        showToast('Kunne ikke fjerne tildeling: ' + error.message, 'error');
      }
    };

    // Remote Control State
    let remoteSession = null;
    let remotePeerConnection = null;
    let remoteDataChannel = null;
    let remoteCanvas = null;
    let remoteCtx = null;
    let remoteStatsInterval = null;
    let remoteFramesReceived = 0;
    let remoteBytesReceived = 0;
    let remoteLastStatsTime = Date.now();
    let remoteInputActive = false;
    // Chunked frame reassembly
    let remoteFrameChunks = [];
    let remoteExpectedChunks = 0;
    let remoteCurrentFrameId = -1;
    let remoteFrameTimeout = null;

    // Load online devices for remote control
    async function loadRemoteDevices() {
      try {
        const { data: devices, error } = await supabase
          .from('remote_devices')
          .select('device_id, device_name, is_online')
          .eq('is_online', true)
          .eq('approved', true)
          .order('device_name');

        if (error) throw error;

        const select = document.getElementById('remoteDeviceSelect');
        select.innerHTML = '<option value="">V√¶lg en online enhed...</option>';

        if (devices && devices.length > 0) {
          devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.device_id;
            option.textContent = device.device_name || device.device_id;
            select.appendChild(option);
          });
        }
      } catch (error) {
        console.error('Error loading remote devices:', error);
      }
    }

    // Select device for remote control
    window.selectRemoteDevice = async function() {
      const deviceId = document.getElementById('remoteDeviceSelect').value;
      if (!deviceId) {
        document.getElementById('remotePreviewContainer').style.display = 'none';
        return;
      }

      const deviceName = document.getElementById('remoteDeviceSelect').selectedOptions[0].textContent;
      document.getElementById('remoteDeviceName').textContent = deviceName;
      document.getElementById('remotePreviewContainer').style.display = 'block';

      // Initialize canvas
      remoteCanvas = document.getElementById('remoteCanvas');
      remoteCtx = remoteCanvas.getContext('2d');

      // Start WebRTC session
      await startRemoteSession(deviceId);
    };

    // Display a full JPEG frame on canvas
    function remoteDisplayFrame(jpegData) {
      const blob = new Blob([jpegData], { type: 'image/jpeg' });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => {
        if (remoteCanvas.width !== img.width || remoteCanvas.height !== img.height) {
          remoteCanvas.width = img.width;
          remoteCanvas.height = img.height;
        }
        remoteCtx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
      };
      img.src = url;
    }

    // Display a dirty region (partial update)
    function remoteDisplayRegion(jpegData, x, y, w, h) {
      const blob = new Blob([jpegData], { type: 'image/jpeg' });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => {
        remoteCtx.drawImage(img, x, y, w, h);
        URL.revokeObjectURL(url);
      };
      img.src = url;
    }

    // Handle agent JSON messages (monitor list, clipboard, etc.)
    function handleRemoteAgentMessage(msg) {
      if (msg.type === 'monitors') {
        console.log('üì∫ Monitor list:', msg.monitors);
      } else if (msg.type === 'clipboard') {
        console.log('üìã Clipboard:', msg.text?.substring(0, 50));
      } else {
        console.log('üì® Agent message:', msg.type);
      }
    }

    // Process incoming data channel message (JPEG frames)
    function handleRemoteDataMessage(event) {
      let dataSize = 0;
      if (event.data instanceof ArrayBuffer) {
        dataSize = event.data.byteLength;
      } else if (event.data instanceof Blob) {
        dataSize = event.data.size;
      } else if (typeof event.data === 'string') {
        dataSize = event.data.length;
        // Try to parse JSON control messages
        try {
          const msg = JSON.parse(event.data);
          handleRemoteAgentMessage(msg);
        } catch(e) {}
        return;
      }
      remoteBytesReceived += dataSize;

      if (event.data instanceof ArrayBuffer) {
        const data = new Uint8Array(event.data);

        // Check if JSON (starts with '{' = 0x7B)
        if (data.length > 0 && data[0] === 0x7B) {
          try {
            const text = new TextDecoder().decode(data);
            const msg = JSON.parse(text);
            handleRemoteAgentMessage(msg);
          } catch (e) {}
          return;
        }

        const FRAME_TYPE_FULL = 0x01;
        const FRAME_TYPE_REGION = 0x02;
        const CHUNK_MAGIC_NEW = 0xFE;

        // Full frame (type 0x01): [type, reserved(3), ...jpeg_data]
        if (data.length > 4 && data[0] === FRAME_TYPE_FULL) {
          remoteDisplayFrame(data.slice(4).buffer);
          remoteFramesReceived++;
        }
        // Dirty region (type 0x02): [type, x_lo, x_hi, y_lo, y_hi, w_lo, w_hi, h_lo, h_hi, ...jpeg]
        else if (data.length > 9 && data[0] === FRAME_TYPE_REGION) {
          const x = data[1] | (data[2] << 8);
          const y = data[3] | (data[4] << 8);
          const w = data[5] | (data[6] << 8);
          const h = data[7] | (data[8] << 8);
          const jpegData = data.slice(9);
          remoteDisplayRegion(jpegData, x, y, w, h);
          remoteFramesReceived++;
        }
        // Chunked frame (0xFE magic): [magic, frameId_hi, frameId_lo, chunkIdx, totalChunks, ...data]
        else if (data.length > 5 && data[0] === CHUNK_MAGIC_NEW) {
          const frameId = (data[1] << 8) | data[2];
          const chunkIndex = data[3];
          const totalChunks = data[4];
          const chunkData = data.slice(5);

          if (remoteCurrentFrameId !== frameId) {
            remoteFrameChunks = new Array(totalChunks);
            remoteExpectedChunks = totalChunks;
            remoteCurrentFrameId = frameId;
            if (remoteFrameTimeout) clearTimeout(remoteFrameTimeout);
            remoteFrameTimeout = setTimeout(() => {
              remoteFrameChunks = [];
              remoteExpectedChunks = 0;
            }, 500);
          }

          if (remoteExpectedChunks > 0 && chunkIndex < remoteExpectedChunks) {
            remoteFrameChunks[chunkIndex] = chunkData;
            const received = remoteFrameChunks.filter(c => c).length;
            if (received === remoteExpectedChunks) {
              if (remoteFrameTimeout) { clearTimeout(remoteFrameTimeout); remoteFrameTimeout = null; }
              const totalLen = remoteFrameChunks.reduce((sum, c) => sum + c.length, 0);
              const complete = new Uint8Array(totalLen);
              let off = 0;
              for (const chunk of remoteFrameChunks) { complete.set(chunk, off); off += chunk.length; }
              // Check reassembled data type: full frame (0x01), dirty region (0x02), or raw JPEG
              if (complete.length > 4 && complete[0] === FRAME_TYPE_FULL) {
                remoteDisplayFrame(complete.slice(4).buffer);
              } else if (complete.length > 9 && complete[0] === FRAME_TYPE_REGION) {
                const rx = complete[1] | (complete[2] << 8);
                const ry = complete[3] | (complete[4] << 8);
                const rw = complete[5] | (complete[6] << 8);
                const rh = complete[7] | (complete[8] << 8);
                remoteDisplayRegion(complete.slice(9), rx, ry, rw, rh);
              } else {
                remoteDisplayFrame(complete.buffer);
              }
              remoteFrameChunks = [];
              remoteExpectedChunks = 0;
              remoteFramesReceived++;
            }
          }
        }
        // Legacy full frame (starts with JPEG SOI marker 0xFF 0xD8)
        else if (data.length > 2 && data[0] === 0xFF && data[1] === 0xD8) {
          remoteDisplayFrame(data.buffer);
          remoteFramesReceived++;
        }
      }
    }

    // Setup mouse/keyboard input on remote canvas
    function setupRemoteInput() {
      if (remoteInputActive) return;
      remoteInputActive = true;
      const canvas = remoteCanvas;

      // Prevent context menu
      canvas.addEventListener('contextmenu', (e) => e.preventDefault());

      // Mouse move
      canvas.addEventListener('mousemove', (e) => {
        if (!remoteDataChannel || remoteDataChannel.readyState !== 'open') return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        remoteDataChannel.send(JSON.stringify({ t: 'mouse_move', x, y }));
      });

      // Mouse down/up
      canvas.addEventListener('mousedown', (e) => {
        if (!remoteDataChannel || remoteDataChannel.readyState !== 'open') return;
        e.preventDefault();
        const buttons = ['left', 'middle', 'right'];
        remoteDataChannel.send(JSON.stringify({ t: 'mouse_click', button: buttons[e.button] || 'left', down: true }));
      });
      canvas.addEventListener('mouseup', (e) => {
        if (!remoteDataChannel || remoteDataChannel.readyState !== 'open') return;
        e.preventDefault();
        const buttons = ['left', 'middle', 'right'];
        remoteDataChannel.send(JSON.stringify({ t: 'mouse_click', button: buttons[e.button] || 'left', down: false }));
      });

      // Mouse scroll (agent expects normalized delta: -1 or 1)
      canvas.addEventListener('wheel', (e) => {
        if (!remoteDataChannel || remoteDataChannel.readyState !== 'open') return;
        e.preventDefault();
        remoteDataChannel.send(JSON.stringify({ t: 'mouse_scroll', delta: e.deltaY > 0 ? -1 : 1 }));
      }, { passive: false });

      // Keyboard
      canvas.setAttribute('tabindex', '0');
      canvas.addEventListener('keydown', (e) => {
        if (!remoteDataChannel || remoteDataChannel.readyState !== 'open') return;
        e.preventDefault();
        remoteDataChannel.send(JSON.stringify({ t: 'key', code: e.code, key: e.key, down: true, shift: e.shiftKey, ctrl: e.ctrlKey, alt: e.altKey, meta: e.metaKey }));
      });
      canvas.addEventListener('keyup', (e) => {
        if (!remoteDataChannel || remoteDataChannel.readyState !== 'open') return;
        e.preventDefault();
        remoteDataChannel.send(JSON.stringify({ t: 'key', code: e.code, key: e.key, down: false, shift: e.shiftKey, ctrl: e.ctrlKey, alt: e.altKey, meta: e.metaKey }));
      });

      // Focus canvas on click
      canvas.addEventListener('click', () => canvas.focus());
    }

    // Start remote WebRTC session
    async function startRemoteSession(deviceId) {
      try {
        updateRemoteStatus('üü° Forbinder...');

        const { data: { session } } = await supabase.auth.getSession();

        // Create session via Edge Function
        const { data: sessionData, error } = await supabase.functions.invoke('session-token', {
          body: { device_id: deviceId, use_pin: false },
          headers: { Authorization: `Bearer ${session.access_token}` }
        });

        if (error) throw error;
        remoteSession = sessionData;

        // Fetch TURN credentials
        let iceServers = [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ];
        try {
          const { data: turnData } = await supabase.functions.invoke('turn-credentials', {
            headers: { Authorization: `Bearer ${session.access_token}` }
          });
          if (turnData && turnData.iceServers) {
            iceServers = turnData.iceServers;
            console.log('üîí TURN credentials fetched');
          }
        } catch(e) { console.warn('TURN fetch failed, using STUN only'); }

        remotePeerConnection = new RTCPeerConnection({ iceServers });
        window._pc = remotePeerConnection; // Debug: expose for WebRTC stats

        // Create data channel BEFORE offer (critical - agent needs this for streaming)
        remoteDataChannel = remotePeerConnection.createDataChannel('control', { ordered: true });
        window._dc = remoteDataChannel; // Debug: expose for inspection
        remoteDataChannel.binaryType = 'arraybuffer';

        remoteDataChannel.onopen = () => {
          console.log('üì° Data channel OPEN - agent will start streaming');
          setupRemoteInput();
        };
        remoteDataChannel.onclose = () => {
          console.log('üì° Data channel closed');
        };
        remoteDataChannel.onmessage = handleRemoteDataMessage;

        // Handle incoming video track (H.264 mode)
        remotePeerConnection.ontrack = (event) => {
          console.log('üìπ Received video track');
          const stream = event.streams[0];
          const video = document.createElement('video');
          video.srcObject = stream;
          video.autoplay = true;
          video.muted = true;
          video.playsInline = true;
          // Append to DOM (required for autoplay in some browsers)
          video.style.position = 'absolute';
          video.style.width = '0';
          video.style.height = '0';
          video.style.opacity = '0';
          document.body.appendChild(video);

          video.onloadedmetadata = () => {
            remoteCanvas.width = video.videoWidth;
            remoteCanvas.height = video.videoHeight;
            function drawFrame() {
              if (video.readyState >= video.HAVE_CURRENT_DATA) {
                remoteCtx.drawImage(video, 0, 0, remoteCanvas.width, remoteCanvas.height);
              }
              requestAnimationFrame(drawFrame);
            }
            drawFrame();
          };
          video.play().catch(e => console.warn('Video autoplay blocked:', e));
        };

        // ICE candidate handler
        remotePeerConnection.onicecandidate = async (event) => {
          if (event.candidate) {
            await sendRemoteSignal({
              session_id: remoteSession.session_id,
              from: 'dashboard',
              type: 'ice',
              candidate: {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
              }
            });
          }
        };

        // Handle connection state
        remotePeerConnection.onconnectionstatechange = () => {
          const state = remotePeerConnection.connectionState;
          console.log('Connection state:', state);

          if (state === 'connected') {
            updateRemoteStatus('üü¢ Forbundet');
            document.getElementById('remoteStats').style.display = 'block';
            startRemoteStats();
          } else if (state === 'disconnected' || state === 'failed') {
            updateRemoteStatus('üî¥ Afbrudt');
            stopRemoteStats();
          }
        };

        // Create offer (with data channel already added)
        const offer = await remotePeerConnection.createOffer({
          offerToReceiveVideo: true,
          offerToReceiveAudio: false
        });
        await remotePeerConnection.setLocalDescription(offer);

        // Send offer via signaling
        await sendRemoteSignal({
          session_id: remoteSession.session_id,
          from: 'dashboard',
          type: 'offer',
          sdp: offer.sdp
        });

        // Listen for answer
        subscribeToRemoteSignaling(remoteSession.session_id);

      } catch (error) {
        console.error('Error starting remote session:', error);
        updateRemoteStatus('üî¥ Fejl: ' + error.message);
      }
    }

    // FPS and RTT stats
    function startRemoteStats() {
      stopRemoteStats();
      remoteLastStatsTime = Date.now();
      remoteFramesReceived = 0;
      remoteBytesReceived = 0;

      remoteStatsInterval = setInterval(async () => {
        const now = Date.now();
        const elapsed = (now - remoteLastStatsTime) / 1000;
        const fps = elapsed > 0 ? (remoteFramesReceived / elapsed).toFixed(1) : 0;
        const mbps = elapsed > 0 ? ((remoteBytesReceived * 8) / elapsed / 1000000).toFixed(2) : 0;

        // Get RTT from WebRTC stats
        let rtt = 0;
        if (remotePeerConnection) {
          try {
            const stats = await remotePeerConnection.getStats();
            stats.forEach(report => {
              if (report.type === 'candidate-pair' && report.state === 'succeeded' && report.currentRoundTripTime) {
                rtt = Math.round(report.currentRoundTripTime * 1000);
              }
            });
          } catch(e) {}
        }

        document.getElementById('remoteStats').textContent = `FPS: ${fps} | RTT: ${rtt}ms | ${mbps} Mbit/s`;
        remoteFramesReceived = 0;
        remoteBytesReceived = 0;
        remoteLastStatsTime = now;
      }, 1000);
    }

    function stopRemoteStats() {
      if (remoteStatsInterval) { clearInterval(remoteStatsInterval); remoteStatsInterval = null; }
    }

    // Send signaling message
    async function sendRemoteSignal(payload) {
      const { error } = await supabase
        .from('session_signaling')
        .insert({
          session_id: payload.session_id,
          from_side: payload.from,
          msg_type: payload.type,
          payload: payload.type === 'ice' ? payload.candidate : { sdp: payload.sdp }
        });

      if (error) throw error;
    }

    // Subscribe to signaling
    function subscribeToRemoteSignaling(sessionId) {
      const channel = supabase
        .channel(`session:${sessionId}`)
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'session_signaling',
          filter: `session_id=eq.${sessionId}`
        }, async (payload) => {
          const signal = payload.new;

          if (signal.from_side === 'agent') {
            if (signal.msg_type === 'answer') {
              const answer = new RTCSessionDescription({
                type: 'answer',
                sdp: signal.payload.sdp
              });
              await remotePeerConnection.setRemoteDescription(answer);
              console.log('‚úÖ Answer received');
            } else if (signal.msg_type === 'ice') {
              const candidate = new RTCIceCandidate(signal.payload);
              await remotePeerConnection.addIceCandidate(candidate);
            }
          }
        })
        .subscribe();
    }

    // Update remote status
    function updateRemoteStatus(text) {
      document.getElementById('remoteStatus').textContent = text;
    }

    // Disconnect remote session
    window.disconnectRemote = function() {
      stopRemoteStats();
      if (remotePeerConnection) {
        remotePeerConnection.close();
        remotePeerConnection = null;
      }
      if (remoteDataChannel) {
        remoteDataChannel.close();
        remoteDataChannel = null;
      }
      remoteInputActive = false;

      updateRemoteStatus('üî¥ Ikke forbundet');
      document.getElementById('remoteStats').style.display = 'none';
      document.getElementById('remotePreviewContainer').style.display = 'none';
      document.getElementById('remoteDeviceSelect').value = '';
    };

    // Tab switching
    window.showTab = function(tab) {
      // Hide all tabs
      document.querySelectorAll('.tab-content').forEach(t => t.style.display = 'none');
      document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
      
      // Show selected tab
      const tabId = tab.charAt(0).toUpperCase() + tab.slice(1);
      document.getElementById(tab + 'Tab').style.display = 'block';
      document.getElementById('tab' + tabId).classList.add('active');
      
      // Load data for specific tabs
      if (tab === 'devices') {
        loadDevices();
      } else if (tab === 'remote') {
        loadRemoteDevices();
      } else if (tab === 'invites') {
        loadInvitations();
      } else if (tab === 'transfers' && isSuperAdmin) {
        loadTransferData();
      }
    };

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('assignModal');
      if (event.target === modal) {
        closeAssignModal();
      }
    };

    // Start the app
    init();
  </script>
</body>
</html>
